'''
Created on May 26, 2009

@author: meloam
'''
import WMCore.Cache.ConfigCache as ConfigCache
import unittest
import tempfile
import os
import md5

testDocument1 = \
"""#!/usr/bin/env python
# TESTDOCUMENT1
#
# StepSpace Init module for Step
# Autogenerated by WMCore.WMSpec.Steps.Builder

__all__ = []

from WMCore.WMRuntime.Bootstrap import establishStepSpace
def _Locator():
    pass
args = {}
""" 

testDocument2 = \
"""#!/usr/bin/env python
# TESTDOCUMENT2
#
# StepSpace Init module for Step
# Autogenerated by WMCore.WMSpec.Steps.Builder

__all__ = []

from WMCore.WMRuntime.Bootstrap import establishStepSpace
def _Locator():
    pass
args = {}
"""
class Test(unittest.TestCase):
    def setUp(self):
        # make the cache object
        #cachedelete = ConfigCache.WMConfigCache('testdb2')
        #cachedelete.deleteDatabase()
        self.cache = ConfigCache.WMConfigCache('testdb2')
        
        # make some temp config files to test with
        (self.fileobj1, self.filename1) = tempfile.mkstemp()
        self.firstmd5 = md5.new( testDocument1 ).hexdigest()
        os.write( self.fileobj1, testDocument1 )
        os.close( self.fileobj1 )
        
        # second config
        self.fileobj2, self.filename2 = tempfile.mkstemp()
        self.secondmd5 = md5.new( testDocument2 ).hexdigest()
        os.write(self.fileobj2, testDocument2 )
        os.close( self.fileobj2 )
        
    def testDuplicate(self):
        """ 
        Adding duplicate configs. the class should just add it once to the DB
        and pass the old value keys/revs back
        """
        newid1, newrev1   = self.cache.addConfig( self.filename1 )
        newid2, newrev2   = self.cache.addConfig( self.filename1 )
        otherid,otherrev  = self.cache.addConfig( self.filename2 )
        self.assertEqual( newid1, newid2 )
        self.assertEqual( newrev1, newrev2 )
    
    def testOriginal(self):
        newid1, newrev1 = self.cache.addConfig( self.filename1 )
        newid1, newrev1 = self.cache.addOriginalConfig(newid1, newrev1,
                                                        self.filename2)
        testString1 = self.cache.getConfigByDocID(newid1)
        testString2 = self.cache.getOriginalConfigByDocID(newid1)

        self.assertEqual( testString1, testDocument1 )
        self.assertEqual( testString2, testDocument2 )
        
    def testAdd(self):
        """
        simple test to make sure we can roundtrip data properly
        """
        self.cache.addConfig( self.filename2 )
        testString = self.cache.getConfigByMD5( self.secondmd5 )
        self.assertEqual( testString, testDocument2 )
        
    def testChangeHash(self):
        """
        make sure that we can set and retrieve data by their pset_hashes
        """
        newid1, newrev1 = self.cache.addConfig( self.filename1 )
        self.cache.modifyHash(newid1, 'demohash')
        testString = self.cache.getConfigByHash('demohash')
        self.assertEqual( testString, testDocument1 )
        
    def testAddDelBarrage(self):
        """
        add and delete files repeatedly
        """
        filehandle = open('test-pset1.py', 'rb')
        sampletext = filehandle.read()
        for i in range(10):
            # made the slightly modified file so the md5 sums dont overlap
            (tmpobj, tmpname) = tempfile.mkstemp()
            newtext = sampletext + ("%s" % i)
            ourmd5 = md5.new( newtext ).hexdigest()
            os.write( tmpobj, newtext )
            os.close( tmpobj )
            
            # add the document to the database
            newid, newrev = self.cache.addConfig( tmpname )
            self.cache.modifyHash(newid, 'demohash'  + ("%s" % i))
            testhashget = self.cache.getConfigByHash('demohash' + ("%s" % i))
            testidget   = self.cache.getConfigByDocID(newid)
            testmd5get  = self.cache.getConfigByMD5( ourmd5 )
            
            # assert we got the same thing each time
            self.assertEqual( newtext, testhashget )
            self.assertEqual( newtext, testidget )
            self.assertEqual( newtext, testmd5get )
            
            # now, delete the document
            self.cache.deleteConfig( newid )
            self.assertRaises( RuntimeError, self.cache.getConfigByDocID, newid )
            
            os.remove( tmpname )
        
    
    def tearDown(self):
        os.remove( self.filename1 )
        os.remove( self.filename2 )
        self.cache.deleteDatabase()

if __name__ == "__main__":
    #import sys;sys.argv = ['', 'Test.testName']
    unittest.main()