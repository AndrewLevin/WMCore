#!/usr/bin/env python
from WMCore.WebTools.Page import DatabasePage, exposexml, exposejson, exposedasjson 
from WMCore.Lexicon import sitetier, countrycode
from cherrypy import expose, HTTPRedirect
import sys

class WebAPI(DatabasePage):
    def __init__(self, config = {}, database = ''):
        """
        __WebAPI__
        To create an auto-documenting API, make a subclass of the WebAPI class, 
        add in methods that represent the api calls (no need to expose them), 
        document them clearly in the methods doc strings and then add to the 
        self.methods dictionary as follows:
        
        self.methods = {'method1':{'args':[],'call':self.method1},
                        'method2':{'args':['id'], 'call': self.method2}}
        
        WebAPI is a subclass of the DatabasePage to make a database connection 
        available to the class in a standard way.
        
        binds = {'id': 123}
        sql = "select * from table where id = :id"
        result = self.dbi.processData(sql, binds)
        return self.formatDict(result)
        
        This can be used in the API methods. You may want to have a read-only 
        API and a write-only API (with appropriately permissions on the DB 
        connections) to minimise risk of SQL injection attacks (always use binds
        variables!).
        """
        DatabasePage.__init__(self, config, database) 
        self.methods = {}
    
    @expose
    def index(self):
        """
        Return the auto-generated documentation for the API
        """
        return self.templatepage('API', methods = self.methods, 
                                 application = self.config.application)
    
    @expose
    def default(self, *args, **kwargs):
        """
        Return the autogenerated documentation for the API (by calling index())
        """
        return self.index()
    
    #TODO: Validate input for json, das and xml
    @exposejson
    def json(self, *args, **kwargs):
        """
        The json output. args is assumed to be length 1 and contain the method 
        name, kwargs are passed to the method
        """
        if len(args) > 0:
            dict = self.runMethod(args[0], kwargs)
            return dict
        else:
            raise HTTPRedirect("doc")
    
    @exposedasjson
    def das(self, *args, **kwargs):
        """
        The das compatible json output. args is assumed to be length 1 and 
        contain the method name, kwargs are passed to the method
        """
        if len(args) > 0:
            dict = self.runMethod(args[0], kwargs)
            return dict
        else:
            raise HTTPRedirect("doc")
    
    @exposexml
    def xml(self, *args, **kwargs):
        """
        The xml output. args is assumed to be length 1 and contain the method 
        name, kwargs are passed to the method
        """
        if len(args) > 0:
            dict = self.runMethod(args[0], kwargs)
            return dict
        else:
            raise HTTPRedirect("doc")
    
    def runMethod(self, method, input):
        """
        Run the specified method with the provided input, return a dict 
        containing the result of the call or an exception wrapped in a dict. 
        """
        dict = {}
        try:
            assert method in self.methods.keys(), "Unknown method called"
            if len(input):
                dict = self.methods[method]['call'](**input)
            else:
                dict = self.methods[method]['call']()
        except Exception, e:
            error = e.__str__()
            self.debug(error)
            self.debug("%s:%s" % (sys.exc_type, sys.exc_value))
            dict = {'Exception':{'Exception_thrown_in': method,
                       'Exception_type': '%s' % sys.exc_type,
                       'Exception_detail':error, 
                       'Exception_arguments': input,
                       'Exception_dict':dict}}
        return dict