#!/bin/env python


"""
======
tqtalk
======
Sends messages/stores files and receives responses from the Task Queue
----------------------------------------------------------------------

Normal operation is to send messages to the Task Queue. If 
the --put option is used, however, a store operation of 
the specified file is performed.

You always need to provide the endpoint of the TQ's 
Listener. In principle, only host and port.

The arguments for messages are as follows:

  First argument should be a valid message type.

  Second argument should be a python expression that will
  become the payload of the message (normally a dict with
  some expected attributes). The specified expression will
  be evaluated as python. Notice that this means that 
  strings should be quoted twice (as indicated by the 
  examples below).

For PUT operations, only the file to store is required 
as argument. But another option, --dest, must be included.
The value of this option must be the destination path
for the file in the server (if ended in '/', the basename
of the local file to upload will be appended. This path
should have been indicated by the TQ previously.


SYNOPSIS
========
tqtalk -e <endpoint> <msgType> <payload-expr>

tqtalk -e <endpoint> --put --dest </some/path/file> <file>

tqtalk [-u | -h]


OPTIONS
=======
-e, --endpoint  Endpoint of the TQ listener to post to (compulsory).
                For the --put

-p, --put       Store specified file on server (rather than default
                behaviour of sending a message).

-d, --dest      Destination path on the server for the uploaded file.

-v, --verbose   Print extra informative messages.

-u, --usage   Usage information is displayed.

-h, --help    Help information is displayed.


EXAMPLES
========
$> tqtalk  -e glitece:20030 registerRequest "{'host': 'somehost.cern.ch',
'site': 'T0_CH_CERN', 'cacheDir': '/my/fake/path/cache', 'ttl': 50000}"

Message sent
Response:
{"msg": {"msgType": "registerResponse", "payload": {"otherPilots": [{"cachedir":
"/some/path/cache", "id": 12}], "pilotid": 23, "registerStatus": "RegisterDone"}}}


$> tqtalk  -e glitece:20030 getTask "{'pilotId': 9}"

Message sent
Response:
{"msg": {"msgType": "TaskAssigned", "payload": {"SandboxUrl": "http://glitece.
ciemat.es:20030/static/sandbox//Test-QCDpt_0_15-IDEAL_V9_TestPA01-Processing.ta
r.gz", "SpecUrl": "http://glitece.ciemat.es:20030/static/spec//Test-QCDpt_0_15-
IDEAL_V9_TestPA01-8-JobSpec.xml", "TaskId": 10}}}


$> tqtalk -e glitece:20030 heartbeat "{'pilotId': 2, 'ttl': 800}"

Message sent
Response:
{"msg": {"msgType": "heartbeatAck", "payload": {"info": "Done"}}}


$> tqtalk  -e glitece:20030 taskEnd "{'pilotId': 14, 'taskId': 43}"

Message sent
Response:
{"msg": {"msgType": "TaskEndACK", "payload": {"Info": "Task updated as Done.",
 "ReportUrl":  "http://glitece.ciemat.es:20030/reports/Test-QCDpt_0_15-IDEAL_V9/
FrameworkJobReport.xml", "TaskId": 43}}}


$> tqtalk -e glitece:20030 --put \
  --dest /upload/reports/Test-QCD/0000/5/FrameworkJobReport.xml /tmp/myfile.tgz

File uploaded
Response:
{"msg": {"msgType": "FileStored", "payload": {"Path": "/Test-QCDpt/0000/5/Frame
workJobReport.xml", "Length": 0}}


$> tqtalk -e glitece:20030 addFile "{'pilotId': 4, 'fileguid': 'f5', 'filesize':
100, 'filetype': 'typeB'}"

Message sent
Response:
{"msg": {"msgType": "addFileAck", "payload": {"info": "Done"}}}


$>tqtalk -e glitece:20030 fileRemoved "{'pilotId': 1, 'fileguid': 'ayUasf36d0'}"

Message sent
Response:
{"msg": {"msgType": "fileRemovedAck", "payload": {"info": "Done"}}}


$> tqtalk -e glitece:20030 pilotShutdown "{'pilotId': 5}"

Message sent
Response:
{"msg": {"msgType": "pilotShutdownAck", "payload": {"info": "Done"}}}
"""

####   IMPORTS   ####
import sys
from traceback import extract_tb
import getopt
from TQComp.CommonUtil import dojson, doencode
import urllib2
import httplib


####   CONSTANTS   ####


####   CLASSES     ####
class Error:
    # indicates an HTTP error
    def __init__(self, url, errcode, errmsg, headers):
        self.url = url
        self.errcode = errcode
        self.errmsg = errmsg
        self.headers = headers
    def __repr__(self):
        return (
            "<Error for %s: %s %s>" %
            (self.url, self.errcode, self.errmsg)
            )


####   FUNCTIONS   ####

def err(msg):
    """
    Prints the specified string msg to standard error (with an added trailing newline)
    """
    sys.stderr.write(msg+'\n')


def help():
    """
    Provides some information regarding this script functionality.

    """
    print globals()['__doc__']
   

def usage():
    """
    Describes usage of the script.
 
    """
    v = globals()['__doc__'].split('\n')
    start = end = 0
    for i in xrange(len(v)):
        if(v[i].startswith("SYNOPSIS")):
            start = i + 2
        if(start and (i > start+1)):
            if(v[i].startswith("====")):
                end = i-2
                break
    print 'Usage:  '+reduce(lambda x,y: x+ '\n        '+y, v[start:end])



####   MAIN   ####
def main():
    """
    Performes the main task of the script (invoked directly).
    For information on its functionality, please call the help function.
    """
 
    # Options
    longoptions=["help", "usage", "verbose", "endpoint=", "put", "dest="]
    try:
        # For options with args, just add ':' after the option letter here
        optlist, args = getopt.getopt(sys.argv[1:], 'huve:pd:', longoptions)
    except getopt.GetoptError, inst:
        err ("Bad usage: %s" % inst)
        usage()
        return 1
    
    verb = False
    endpoint = None
    put = False
    dest = None
    fileType = None
    for opt, val in optlist:
        if opt in ("-h", "--help"):
            help()
            sys.exit(0)
        elif opt in ("-u", "--usage"):
            usage()
            sys.exit(0)
        elif opt in ("-v", "--verbose"):
            verb = True
        elif opt in ("-e","--endpoint"):
            endpoint = val
        elif opt in ("-p","--put"):
            put = True
        elif opt in ("-d","--dest"):
            dest = val
 
    # Endpoint 
    if not endpoint:
        err("You need to provide and endpoint!")
        usage()
        return 2
            
    # Args           
    if not put:
        if len(args) < 2:
            err("Not enough input arguments!")
            usage()
            return 2
    else:
        if not dest:
            err("For PUT operations, the --dest option is compulsory!")
            usage()
            return 2
  
 
    #### REAL MAIN ####

    if not put:
 
        baseurl = "http://%s/msg" % (endpoint)
        if verb:
            print "-- Base URL: %s" % baseurl
        
        try:
            if verb:
                print "-- Payload: %s" % args[1]
            expr = eval(args[1])
            if verb:
                print "-- Evaluated: %s" % expr
            expr = dojson(expr)
            if verb:
                print "-- Json: %r" % expr

            postargs = doencode((("msgType", "%s" % args[0]), ("payload",expr)))
            if verb:
                print "-- Encoded: %r" % postargs
                
            conn = urllib2.urlopen(baseurl, postargs)
            all  = conn.readlines()
            conn.close()
            print "\nMessage sent"
            print "Response:"
            for line in all:
                print line

        except:
            type, val, tb = sys.exc_info()
            err("Error with arg %s: %s - %s. Trace: %s" % \
               (args[1], type, val, extract_tb(tb, limit=5)))

    else:
        try:
            if not dest.endswith('/'):
                path = dest
            else:
                basefile = args[0].split('/')[-1]
                path = dest + basefile

            if verb:
                print "-- Dest path: %s" % path

            http = httplib.HTTP(endpoint)
            USER_AGENT = 'tqtalk'

            f = open(args[0])
            data = f.read()
            f.close()

            # write header
            http.putrequest("PUT", path)
            http.putheader("User-Agent", USER_AGENT)
            http.putheader("Host", endpoint.split(':')[0])
            if fileType:
                http.putheader("Content-Type", filteType)
            else:
                http.putheader("Content-Type", "application/octet-stream")
            http.putheader("Content-Length", str(len(data)))
            http.endheaders()

            # write body
            http.send(data)

            # get response
            errcode, errmsg, headers = http.getreply()

            if errcode != 200:
                raise Error(endpoint+path, errcode, errmsg, headers)

            file = http.getfile()
            lines = file.readlines()
            for line in lines:
                    print line

        except:
            type, val, tb = sys.exc_info()
            err("Error when uploading %s: %s - %s. Trace: %s" % \
               (args[0], type, val, extract_tb(tb, limit=5)))

 
    # Exit successfully
    return 0
 
 
###    SCRIPT    ####
if __name__=="__main__":
   sys.exit(main())




