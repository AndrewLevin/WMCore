#!/bin/env python

"""
==========
encodejson
==========
Dumps as json and encodes data for use with HTTP
------------------------------------------------

Accepts any arguments, tries to "eval" them as python expressions
(if impossible an error message is shown) and then jsons the result
to form a string and encodes this with urllib.encode. The output can be 
then used as argument of an HTTP request (where the remote end is ready 
to 'unjson' the result). It can be used e.g. to test the RemoteMsg with 
a web browser.

You need to enclose every argument with quotes.


SYNOPSIS
========
encodejson <arg1> [<arg2> ..]

encodejson [-u | -h]


OPTIONS
=======
-v, --verbose   Print of extra informative messages in the run
                of the command. 

-u, --usage   Usage information is displayed.

-h, --help    Help information is displayed.


EXAMPLE
=======
$> encodejson "['a','b','c']"   "'asdf'"
%5B%22a%22%2C+%22b%22%2C+%22c%22%5D
%22asdf%22

"""


####   IMPORTS   ####
import sys
import getopt
#from RemoteMsgComp.CommonUtil import dojson, doencode
from TQComp.CommonUtil import dojson, doencode


####   CONSTANTS   ####


####   FUNCTIONS   ####

def err(msg):
   """
   Prints the specified string msg to standard error (with an added trailing newline)
   """
   sys.stderr.write(msg+'\n')


def help():
   """
    Provides some information regarding this script functionality.

   """
   print globals()['__doc__']
   

def usage():
   """
    Describes usage of the script.

   """
   v = globals()['__doc__'].split('\n')
   start = end = 0
   for i in xrange(len(v)):
      if(v[i].startswith("SYNOPSIS")):
         start = i + 2
      if(start and (i > start+1)):
         if(v[i].startswith("====")):
           end = i-2
           break
   print 'Usage:  '+reduce(lambda x,y: x+ '\n        '+y, v[start:end])



####   MAIN   ####
def main():
   """
    Performes the main task of the script (invoked directly).
    For information on its functionality, please call the help function.
   """

   # Options
   longoptions=["help", "usage", "verbose"]
   try:
      # For options with args, just add ':' after the option letter here
      optlist, args = getopt.getopt(sys.argv[1:], 'huv', longoptions)
   except getopt.GetoptError, inst:
      err ("Bad usage: %s" % inst)
      usage()
      return 1
   
   verb = False
      
   for opt, val in optlist:
       if opt in ("-h", "--help"):
           help()
           sys.exit(0)
       elif opt in ("-u", "--usage"):
           usage()
           sys.exit(0)
       elif opt in ("-v", "--verbose"):
           verb = True
#       elif opt in ("-f","--from-file"):
#           fname = val

           
   # Args           
   if(len(args)<1):
      err("Not enough input arguments!")
      usage()
      return 2
 

   #### REAL MAIN ####
   for arg in args:
      try:
        if verb:
           print "-- ARG: %s" % arg
        expr = eval(arg)
        if verb:
           print "-- Evaluated: %s" % expr
        expr = dojson(expr)
        if verb:
           print "-- Json: %r" % expr
        expr = doencode([('ARG',expr)])
        if verb:
           print "-- Encoded: %r" % expr
        print expr[4:]
      except Exception, inst:
        err("There was some problem trying to encodejson arg %s: %s" % (arg,inst))


   # Exit successfully
   return 0


###    SCRIPT    ####
if __name__=="__main__":
   sys.exit(main())



